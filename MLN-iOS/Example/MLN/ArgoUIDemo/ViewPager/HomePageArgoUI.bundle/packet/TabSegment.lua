---
--- Generated by MLNUI(https://github.com/momotech/MLN)
--- Created by momo.
--- DateTime: 2020-07-18 11:08
---

local _class = {
    ---@private
    _currentIndex = nil,
    _progressBar = nil,
    _subviews = {},
    _animCache = {},
    _onSelected = nil,
    _autoAnimTime = 0.2,
    _viewpager = nil,
    ---@public
    contentView = nil
}
_class._type = 'ui'

---
--- @public
---
function TabSegment(texts, items, progressBar)
    local obj = {}
    setmetatable(obj, _class)
    if texts or items or progressBar then
        obj:setup(texts, items, progressBar)
    end
    return obj
end

function _class:new(texts)
    local obj = {}
    setmetatable(obj, _class)
    return obj:setup(texts, nil, nil)
end

function _class:create(items, progressBar)
    local obj = {}
    setmetatable(obj, _class)
    return obj:setup(nil, items, progressBar)
end

function _class:setup(texts, items, progressBar)
    if not texts and not items then
        error("The texts and items can not be nil together", 2)
    end
    if not items then
        items = self:_defaultItems(texts)
    end
    self._progressBar = progressBar
    self:_defaultAnimation()
    self:_setupUI(items)
    return self
end

function _class:setAnimation(type, fromValue, toValue)
    self._animType = type
    self._from = fromValue
    self._to = toValue
end

function _class:setCurrentIndex(index)
    if not self._isClickTabSegment then
        self._currentIndex = index
    end
end

function _class:getCurrentIndex()
    return self._currentIndex
end

function _class:scroll(fromIndex, toIndex, progress)
    if not self._isClickTabSegment and fromIndex ~= toIndex then
        self:_updateItemsUI(fromIndex, toIndex, progress, false)
    end
end

function _class:onSelected(callback)
    self._onSelected = callback
end

---
--- @private
---
function _class:_defaultItems(texts)
    if not texts or #texts == 0 then
        return nil
    end
    local items = {}
    for _, v in ipairs(texts) do
        local label = Label():text(v):textAlign(TextAlign.CENTER):fontSize(15)
        table.insert(items, label)
    end
    return items
end

function _class:_defaultAnimation()
    self._animType = AnimProperty.Scale
    self._from = {1.0, 1.0}
    self._to = {1.5, 1.5}
end

function _class:_setupUI(items)
    if not items or #items == 0 then
        error("The items can not be nil when init MLNUITabSegment", 2)
    end
    if self.contentView then
        self.contentView:removeFromSuper()
        self.contentView = nil
    end
    local scrollView = ScrollView(true):showsHorizontalScrollIndicator(false):height(50)
    local container = VStack():basis(1):crossSelf(CrossAxis.STRETCH)
    local itemsView = HStack():basis(1):padding(15, 30, 10, 0):crossAxis(CrossAxis.STRETCH):mainAxis(MainAxis.SPACE_EVENLY)

    for i, v in ipairs(items) do
        v:marginLeft(30):onClick(function()
            self._isClickTabSegment = true
            self:_clickItem(i, true)
        end)
        table.insert(self._subviews, v)
        itemsView:addView(v)
        v:layoutComplete(function()
            self:_executeItemAnimation(v, false, 1, false)
            self:_clickItem((self._currentIndex and self._currentIndex or 1), false) --UI布局完成后需要设置默认选中效果
        end)
    end

    scrollView:addView(container)
    container:addView(itemsView)

    if not self._progressBar then
        self._progressBar = ImageView():width(10):height(5):cornerRadius(2.5):bgColor(Color(0,0,0))
    end
    self._progressBarWidth = (self._progressBar:width() > 0) and self._progressBar:width() or 10 --处理极端情况：progressBar动画过程中，快速点击tab获取的width是不准的
    container:addView(self._progressBar)
    self.contentView = scrollView
end

function _class:_clickItem(index, autoAnim)
    if autoAnim and index == self._currentIndex then
        return --多次点击同一个tabItem
    end
    local oldIndex = self._currentIndex
    self._currentIndex = index --尽可能早地更新_currentIndex，处理快速点击的问题
    if self._onSelected and type(self._onSelected) == "function" then
        self._onSelected(index, self._autoAnimTime)
    end
    self:scrollToViewPagerPage(index, self._autoAnimTime)
    self:_updateItemsUI(oldIndex, index, 1, autoAnim)
end

function _class:_updateItemsUI(fromIndex, toIndex, progress, autoAnim)
    if fromIndex and fromIndex > 0 then
        local old = self._subviews[fromIndex]
        self:_executeItemAnimation(old, false, progress, autoAnim)
    end
    local new = self._subviews[toIndex]
    self:_executeItemAnimation(new, true, progress, autoAnim)
    self:_executeProgressBarAnimation(fromIndex, toIndex, progress, autoAnim)
    self:_executeScrollViewOffsetAnimation(toIndex, progress, autoAnim)
end

function _class:_executeProgressBarAnimation(fromIndex, toIndex, progress, autoAnim)
    local fromItem = fromIndex and self._subviews[fromIndex] or nil
    local toItem = self._subviews[toIndex]
    if not toItem then return end

    local anims = self._animCache[self._progressBar]

    if not self._doingFromIndex  then self._doingFromIndex = fromIndex end
    if not self._doingToIndex then self._doingToIndex = toIndex end
    if self._doingFromIndex ~= fromIndex or self._doingToIndex ~= toIndex then
        anims = nil --should recreate animation
    end

    if not anims then
        local posXAnim = ObjectAnimation(AnimProperty.PositionX, self._progressBar)
        local fromValue = fromItem and (fromItem:centerX() - self._progressBarWidth / 2) or 0
        local toValue = toItem:centerX() - self._progressBarWidth / 2
        posXAnim:from(fromValue)
        posXAnim:to(toValue)
        posXAnim:duration(self._autoAnimTime)
        posXAnim:finishBlock(function()
            self._animCache[self._progressBar] = nil --下次重新创建动画
        end)

        local widthAnimSet = AnimatorSet()
        local widthAnim1 = ObjectAnimation(AnimProperty.ScaleX, self._progressBar)
        local offset = fromItem and math.abs((toItem:centerX() - fromItem:centerX()) / (math.abs(toIndex - fromIndex) + 2)) or 0
        local maxWidth = 10 + offset  --10 is initial width
        widthAnim1:from(1)
        widthAnim1:to(maxWidth / 10)
        widthAnim1:duration(self._autoAnimTime / 2)

        local widthAnim2 = ObjectAnimation(AnimProperty.ScaleX, self._progressBar)
        widthAnim2:from(maxWidth / 10)
        widthAnim2:to(1)
        widthAnim2:duration(self._autoAnimTime / 2)

        widthAnimSet:sequentially{widthAnim1, widthAnim2}
        widthAnimSet:finishBlock(function(_)
            self._animCache[self._progressBar] = nil --下次重新创建动画
        end)

        anims = {posXAnim, widthAnimSet}
        self._animCache[self._progressBar] = anims
    end

    local posXAnim, widthAnimSet = anims[1], anims[2]

    if autoAnim then
        posXAnim:start()
        widthAnimSet:start()
    else
        posXAnim:update(progress)
        widthAnimSet:update(progress)
        if progress >= 1 then
            self._animCache[self._progressBar] = nil
        end
    end
end

function _class:_executeScrollViewOffsetAnimation(toIndex, progress, autoAnim)
    local toItem = self._subviews[toIndex]
    if not toItem then return end

    local anim = self._animCache[self.contentView]
    if not anim then
        anim = ObjectAnimation(AnimProperty.ContentOffset, self.contentView)
        anim:finishBlock(function() self._previousContentOffsetX = self.contentView:contentOffset():x() end)
        self._animCache[self.contentView] = anim
    end
    anim:stop() --must stop previous animation

    if not self._previousContentOffsetX then
        self._previousContentOffsetX = 0
    end

    local offset = 0
    local centerX = toItem:centerX()
    local viewWidth = self.contentView:width()
    local contentSizeWidth = self.contentView:contentSize():width()
    if centerX < viewWidth / 2 then
        offset = 0
    elseif centerX > contentSizeWidth - viewWidth / 2 then
        local contentWidth = (contentSizeWidth > viewWidth) and contentSizeWidth or viewWidth
        offset = contentWidth - viewWidth
    else
        offset = centerX - viewWidth / 2
    end

    anim:from(self._previousContentOffsetX, 0)
    anim:to(offset, 0)

    if autoAnim then
        anim:duration(self._autoAnimTime)
        anim:start()
    else
        anim:update(progress)
        if progress >= 1 then self._previousContentOffsetX = self.contentView:contentOffset():x() end
    end
end

function _class:_executeItemAnimation(item, positive, progress, auto)
    if not item then
        return nil
    end

    local anim = self._animCache[item]
    if not anim then
        anim = ObjectAnimation(self._animType, item)
        anim:finishBlock(function() self._isClickTabSegment = false end)
        self._animCache[item] = anim
    end
    anim:stop() --must stop previous animation

    if positive then
        anim:from(self._from[1], self._from[2], self._from[3], self._from[4])
        anim:to(self._to[1], self._to[2], self._to[3], self._to[4])
    else
        anim:from(self._to[1], self._to[2], self._to[3], self._to[4])
        anim:to(self._from[1], self._from[2], self._from[3], self._from[4])
    end

    if auto then
        anim:duration(self._autoAnimTime)
        anim:start()
    else
        anim:update(progress)
    end
end


function _class:bindViewPager(vpid)
    self._viewpager = vpid
    vpid.segmentSelectedPage = function(fr, to)
        self:setCurrentIndex(to)
    end
    vpid.segmentScrollingListenrer = function(percent, fr, to)
        self:scroll(fr, to, percent)
    end
end

function _class:scrollToViewPagerPage(index, time)
    if self._viewpager then
        self._viewpager:scrollToPage(index, time)
    end
end


---
--- meta
_class.__index = function(t, k)
    local method = _class[k]
    if method ~= nil then
        return method
    end
    local contentView = rawget(t, "contentView")
    if contentView and contentView[k] then
        t.__method = k
        return t
    end
    return method
end

_class.__call = function(t, k, ...)
    local ret = (k.contentView[t.__method])(k.contentView, ...)
    if ret == k.contentView then return t end
    return ret
end

return _class